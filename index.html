<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tietoprovinssi Voice-Image-Edit</title>
    <link href="https://fonts.googleapis.com/css2?family=Exo:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <!-- frontend backend communication -->
    <script src="https://cdn.socket.io/4.1.2/socket.io.min.js"></script>
    <!-- ort is required by vad -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.js"></script>
    <!-- vad for audio recording -->
    <script src="https://cdn.jsdelivr.net/npm/@ricky0123/vad/dist/index.browser.js"></script>
    <!-- font awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
    <!-- speech bubble font -->
    <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:ital,wght@1,700&display=swap" rel="stylesheet" />
    <!-- tree view visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/treant-js/1.0/Treant.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.3.0/raphael.js"></script>
    <script src="https://unpkg.com/panzoom@9.4.0/dist/panzoom.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
      }

      body {
        font-family: sans-serif;
        font-family: "Exo", sans-serif;
        background: #070815;
        color: white;
        display: flex;
        flex-direction: column;
        height: 100vh;
        align-items: center;
        overflow: hidden;
      }

      .main-page {
        display: flex;
        flex-direction: column;
        align-items: center;
        height: 100%;
        width: calc(100% - 725px);
      }

      #spinner_container {
        position: absolute;
        display: none;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.25);
      }

      .spinner {
        border: 16px solid #f3f3f3;
        border-radius: 50%;
        border-top: 16px solid #3498db;
        width: 120px;
        height: 120px;
        animation: spin 2s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      #connection_overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(7, 8, 21, 0.95);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        gap: 30px;
      }

      #connection_overlay.hidden {
        display: none;
      }

      .connection-spinner {
        border: 8px solid rgba(255, 255, 255, 0.2);
        border-radius: 50%;
        border-top: 8px solid #3498db;
        width: 80px;
        height: 80px;
        animation: spin 1s linear infinite;
      }

      .connection-message {
        font-size: 1.5rem;
        color: white;
        font-weight: 500;
        text-align: center;
      }

      h1 {
        text-align: center;
        font-weight: lighter;
        margin: 10px;
      }

      h2 {
        text-align: center;
        font-weight: lighter;
      }

      h3 {
        text-align: center;
        font-weight: lighter;
      }

      h5 {
        text-align: center;
        font-weight: lighter;
      }

      .p-text {
        font-size: 1.2rem;
        color: white;
        font-family: "Exo", sans-serif;
      }

      .flex-center {
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 4px;
      }

      .flex-horizontal {
        display: flex;
        align-items: center;
      }

      .flex-vertical {
        display: flex;
        flex-direction: column;
      }

      .container {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        margin: 10px;
      }

      .custom-textarea {
        flex: 1;
        margin: 10px;
        padding: 10px;
        color: white;
        background-color: transparent;
        border: 1px solid white;
        border-radius: 5px;
        resize: none;
        font-size: 1em;
        pointer-events: none;
        font-family: "Exo", sans-serif;
        width: 300px;
        height: 75px;
      }

      .arrow {
        color: white;
        font-size: 1.5em;
        white-space: nowrap;
      }

      .controls-content {
        display: flex;
        flex-direction: row;
        padding: 20px;
        align-items: center;
        justify-content: space-evenly;
        width: 1200px;
      }

      .textareas-container {
        display: flex;
      }

      .input-container {
        display: flex;
        flex-direction: column;
      }

      .gen-image-container {
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        width: 100%;
      }

      #generated_image {
        object-fit: contain;
        height: calc(100vh - 400px);
        width: auto;
        border-radius: 8px;
      }

      .mic-status {
        width: 125px;
        color: lightcoral;
        border: 2px solid lightcoral;
        border-radius: 8px;
        padding: 8px;
        display: flex;
        align-items: start;
        flex-direction: column;
      }

      .mic-icon {
        margin: 0 4px;
      }

      .rb-input {
        margin: 0 4px 0 8px;
      }

      .cb-input {
        margin: 0 4px 0 4px;
      }

      .width-125 {
        width: 125px;
        text-align: start;
      }

      .width-250 {
        width: 250px;
        text-align: start;
      }

      .height-50 {
        height: 75px;
        justify-content: space-evenly;
      }

      .font-bold {
        font-weight: 600;
      }

      .gen-image-buttons {
        position: absolute;
        display: flex;
        width: 100%;
        height: 100%;
      }

      .gallery_chart_button {
        position: relative;
        width: 50%;
        border: none;
        padding: 10px;
        background: transparent;
        border-radius: 8px;
        cursor: pointer;
        opacity: 0.25;
        color: white;
        font-size: 2.5rem;
        font-weight: bold;
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
      }

      .gallery_chart_button:hover {
        opacity: 0.75;
        background: rgba(255, 255, 255, 0.25);
      }

      .gallery_chart_button .text_image_div {
        width: 45%;
      }

      .gallery_chart_button .spacer_div {
        width: 55%;
      }

      .gallery_chart_button img {
        max-width: 100%;
        max-height: 100%;
        object-fit: cover;
        transform: rotate(-90deg);
        filter: brightness(0) invert(1);
        opacity: 0.75;
      }

      .gallery {
        padding: 10px;
        display: none;
        flex-wrap: wrap;
        justify-content: space-around;
      }

      .gallery .image-container {
        position: relative;
        margin: 5px;
        flex: 1 1 calc(20% - 10px);
        text-align: center;
        box-sizing: border-box;
      }
      .gallery .image-container img {
        width: 100%;
        height: auto;
        display: block;
      }
      .gallery .overlay {
        position: absolute;
        bottom: 5%;
        left: 50%;
        color: white;
        background-color: rgba(0, 0, 0, 0.5);
        padding: 5px;
        transform: translate(-50%, -50%);
        pointer-events: none;
      }
      .gallery img:hover {
        cursor: pointer;
        filter: brightness(1.1);
        transform: scale(1.025);
        transition: all 0.25s ease-in-out;
      }
      .gallery .download-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 4px;
        cursor: pointer;
        opacity: 0;
        transition: opacity 0.2s;
      }

      .gallery .image-container:hover .download-btn {
        opacity: 1;
      }
      @media (max-width: 1600px) {
        .gallery .image-container {
          flex: 1 1 calc(25% - 10px);
        }
      }
      @media (max-width: 1200px) {
        .gallery .image-container {
          flex: 1 1 calc(33.333% - 10px);
        }
      }
      @media (max-width: 800px) {
        .gallery .image-container {
          flex: 1 1 calc(50% - 10px);
        }
      }
      @media (max-width: 500px) {
        .gallery .image-container {
          flex: 1 1 calc(100% - 10px);
        }
      }

      #panzoom_parent {
        display: none;
      }

      .node {
        position: absolute;
      }

      .node img {
        width: 100px;
        height: 100px;
      }

      .node img:hover {
        cursor: pointer;
        filter: brightness(1.1);
        transform: scale(1.025);
        transition: all 0.25s ease-in-out;
      }
      .node p {
        font-size: 8px;
        line-height: 10px;
        font-weight: bold;
        padding: 3px;
        border: 2px solid white;
        background: #070815;
        width: 48px;
      }

      .logo-image {
        display: none;
        position: absolute;
        right: 0;
        bottom: 0;
        height: 300px;
        margin: 10px;
        opacity: 1;
      }

      .jr-image {
        position: absolute;
        left: 0;
        bottom: 0;
        height: 250px;
        opacity: 1;
      }

      .jr-image:hover {
        cursor: pointer;
        filter: brightness(1.1);
        transform: scale(1.025);
        transition: all 0.25s ease-in-out;
      }

      .hb::before {
        content: "";
        display: block;
        position: absolute;
      }

      .bubble {
        position: absolute;
        color: black;
        border: 0.5vmin solid black;
        border-radius: 100%;
        width: 275px;
        height: 175px;
        left: 75px;
        bottom: 225px;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        font-size: 1.5rem;
        background: #ffd;
        box-shadow: 0 -0.25vmin, 0 0.125vmin;
        font-family: "Comic Sans", "Comic Neue", sans-serif;
        opacity: 0;
        transition: all 0.5s ease-in-out;
      }

      .bubble::before {
        width: 40%;
        height: 100%;
        bottom: -54%;
        border-radius: 50%;
        left: 10%;
        box-shadow: 0.5vmin 0, 2vmin -0.5vmin #ffd, 2vmin -0.5vmin 0 0.5vmin;
        clip-path: polygon(0% 49%, 150% 48%, 150% 100%, 0% 100%);
        transform: rotate(-3deg);
      }
    </style>
  </head>
  <body id="body">
    <div id="connection_overlay">
      <div class="connection-spinner"></div>
      <div class="connection-message">Waiting for connection...</div>
    </div>
    <div class="main-page" id="main_page">
      <img id="logo_image" class="logo-image" src="https://raw.githubusercontent.com/Koodattu/ucs-llm-voice-image-edit/main/assets/gls.png" />
      <div id="speech_bubble" class="bubble hb">Koita vaikka sanoa notta "tees mulle uus kuva tekoälyagentista"</div>
      <img id="jr_image" class="jr-image" src="https://raw.githubusercontent.com/Koodattu/ucs-llm-voice-image-edit/main/assets/gls_wide.png" />
      <h1>Voice Guided AI-Powered Imaging</h1>

      <div class="controls-content">
        <div>
          <div class="flex-horizontal">
            <h3>Microphone:&nbsp;&nbsp;</h3>
            <div id="mic_status_box" class="mic-status">
              <div class="flex-horizontal">
                <i id="mic_icon_closed" class="fa fa-microphone-slash mic-icon" style="display: block"></i>
                <i id="mic_icon_open" class="fa fa-microphone mic-icon" style="display: none"></i>
                <p id="mic_status_txt" class="font-bold">Muted</p>
              </div>
              <label id="mic_help" style="margin: 4px">Hold spacebar</label>
            </div>
          </div>
        </div>
        <div class="input-container height-50">
          <div class="flex-center">
            <h3>Language:&nbsp;</h3>
            <div class="flex-vertical">
              <div>
                <input class="rb-input" type="radio" id="rb_auto" name="rb_lang" checked="true" />
                <label for="rb_auto">Auto</label>
              </div>
              <div>
                <input class="rb-input" type="radio" id="rb_en" name="rb_lang" />
                <label for="rb_en">English</label>
              </div>
              <div>
                <input class="rb-input" type="radio" id="rb_fi" name="rb_lang" />
                <label for="rb_fi">Finnish</label>
              </div>
            </div>
          </div>
        </div>
        <div class="input-container height-50">
          <div class="flex-center">
            <h3>Models:&nbsp;</h3>
            <div class="flex-vertical">
              <div>
                <input class="rb-input" type="radio" id="rb_cloud" name="rb_model" checked="true" />
                <label for="rb_cloud">Cloud</label>
              </div>
              <div>
                <input class="rb-input" type="radio" id="rb_local_fast" name="rb_model" disabled />
                <label for="rb_local_fast">Local (Fast Edits)</label>
              </div>
              <div>
                <input class="rb-input" type="radio" id="rb_local_slow" name="rb_model" disabled />
                <label for="rb_local_slow">Local (Better Edits)</label>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="textareas-container">
        <div class="container">
          <div>
            <h5>Transcription</h5>
            <textarea id="transcription" class="custom-textarea"></textarea>
          </div>
          <div id="llm_arrows">
            <h5>→</h5>
            <h5>→</h5>
            <h5>→</h5>
          </div>
          <div>
            <h5>Action & Prompt</h5>
            <textarea id="llm_response" class="custom-textarea"></textarea>
          </div>
        </div>
      </div>

      <div>
        <h5>System Status</h5>
        <h3 id="system_status" class="font-bold">Waiting for connection...</h3>
      </div>

      <div class="gen-image-container">
        <img id="generated_image" src="https://raw.githubusercontent.com/Koodattu/ucs-llm-voice-image-edit/main/assets/canvas.webp" alt="" />
        <div class="gen-image-buttons">
          <button id="chart_button" class="gallery_chart_button">
            <div class="text_image_div">
              <p>TREE</p>
              <img src="https://raw.githubusercontent.com/Koodattu/ucs-llm-voice-image-edit/main/assets/tree_chart.png" />
            </div>
            <div class="spacer_div"></div>
          </button>
          <button id="gallery_button" class="gallery_chart_button">
            <div class="spacer_div"></div>
            <div class="text_image_div">
              <p>GALLERY</p>
              <img src="https://raw.githubusercontent.com/Koodattu/ucs-llm-voice-image-edit/main/assets/gallery.webp" />
            </div>
          </button>
        </div>
        <div id="spinner_container">
          <div id="spinner" class="spinner"></div>
        </div>
      </div>
    </div>

    <div class="gallery" id="gallery"></div>

    <div id="panzoom_parent">
      <div class="tree-view" id="tree_view"></div>
    </div>

    <script>
      const body = document.getElementById("body");
      const main_page = document.getElementById("main_page");
      const gallery = document.getElementById("gallery");
      const tree_view = document.getElementById("tree_view");
      const panzoom_parent = document.getElementById("panzoom_parent");
      const panzoom_element = panzoom(panzoom_parent, {
        beforeWheel: function (e) {
          return panzoom_parent.style.display === "none";
        },
      });
      body.onmousemove = (e) => {
        panzoom_element.setTransformOrigin({
          x: e.clientX / window.innerWidth - 0.3,
          y: e.clientY / window.innerHeight,
        });
      };
      body.onmousemove = (e) => {
        panzoom_element.setTransformOrigin({
          x: e.clientX / window.innerWidth - 0.3,
          y: e.clientY / window.innerHeight,
        });
      };

      const logo_image = document.getElementById("logo_image");
      const jr_image = document.getElementById("jr_image");

      const transcription = document.getElementById("transcription");
      const llm_response = document.getElementById("llm_response");
      transcription.value = "";
      llm_response.value = "";
      const generated_image = document.getElementById("generated_image");
      const spinner_cont = document.getElementById("spinner_container");
      const speech_bubble = document.getElementById("speech_bubble");

      const mic_status_box = document.getElementById("mic_status_box");
      const mic_status_txt = document.getElementById("mic_status_txt");
      const mic_help = document.getElementById("mic_help");
      const system_status = document.getElementById("system_status");

      const rb_auto = document.getElementById("rb_auto");
      const rb_en = document.getElementById("rb_en");
      const rb_fi = document.getElementById("rb_fi");

      const rb_local_fast = document.getElementById("rb_local_fast");
      const rb_local_slow = document.getElementById("rb_local_slow");
      const rb_cloud = document.getElementById("rb_cloud");

      const gallery_button = document.getElementById("gallery_button");
      const chart_button = document.getElementById("chart_button");

      // State
      let socket = null;
      let isRecording = false;
      let isSpacePressed = false;
      let backendProcessing = false;
      let shouldClearTranscription = false;
      let mediaRecorder = null;
      let audioChunks = [];
      let sessionInfo = {};
      let displayedImages = new Set();
      let language = "";
      let speechBubbleEnabled = false;
      let selectedModel = "cloud";
      let hasAudioData = false; // Track if actual audio data is being captured
      let userId = null; // User ID stored in localStorage
      let audioContext = null;
      let analyser = null;
      let audioLevelCheckInterval = null;
      let myvad = null; // VAD instance for partial transcriptions

      // Get or create user ID from localStorage
      function getUserId() {
        let storedUserId = localStorage.getItem("voice_imaging_user_id");
        if (!storedUserId) {
          // Generate a new random user ID
          storedUserId = "user_" + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
          localStorage.setItem("voice_imaging_user_id", storedUserId);
        }
        return storedUserId;
      }

      // Initialize
      document.addEventListener("DOMContentLoaded", async () => {
        userId = getUserId(); // Get or create user ID first
        await loadSessionInfo();
        initializeSocket();
        initializeMicrophone();
        updateGallery();
        updateMicStatus(); // Initialize mic status display

        // Send initial language and model selections to server
        // Wait a bit for socket to connect
        setTimeout(() => {
          if (socket && socket.connected) {
            socket.emit("user_id", userId); // Send user ID to server
            socket.emit("lang_select", ""); // Auto language
            socket.emit("mdl_select", selectedModel); // Use the selected model from session info
          }
        }, 500);
      });

      async function loadSessionInfo() {
        try {
          const response = await fetch("/kuvagen/api/session_info", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ user_id: userId }),
          });
          sessionInfo = await response.json();

          // Update UI based on backend availability from session info
          if (sessionInfo.backend_available) {
            rb_local_fast.disabled = false;
            rb_local_slow.disabled = false;

            // Set default model based on what backend returned
            if (sessionInfo.default_model === "localslow") {
              rb_local_slow.checked = true;
              selectedModel = "localslow";
            } else if (sessionInfo.default_model === "localfast") {
              rb_local_fast.checked = true;
              selectedModel = "localfast";
            } else {
              rb_cloud.checked = true;
              selectedModel = "cloud";
            }
          } else {
            rb_local_fast.disabled = true;
            rb_local_slow.disabled = true;
            if (rb_local_fast.checked || rb_local_slow.checked) {
              rb_cloud.checked = true;
              selectedModel = "cloud";
            }
          }
        } catch (error) {
          console.error("Error loading session info:", error);
          // On error, disable local options
          rb_local_fast.disabled = true;
          rb_local_slow.disabled = true;
        }
      }

      function initializeSocket() {
        socket = io({ path: "/kuvagen/socket.io" });

        socket.on("connect", () => {
          console.log("Connected to server");
          system_status.textContent = "Connected! Ready to go!";
          // Hide connection overlay
          const connectionOverlay = document.getElementById("connection_overlay");
          connectionOverlay.classList.add("hidden");
        });

        socket.on("disconnect", () => {
          console.log("Disconnected from server");
          system_status.textContent = "Disconnected from server";
          // Show connection overlay again
          const connectionOverlay = document.getElementById("connection_overlay");
          connectionOverlay.classList.remove("hidden");
        });

        socket.on("status", (data) => {
          console.log("Status:", data);
          system_status.textContent = data;
        });

        socket.on("empty_transcription", (data) => {
          system_status.textContent = data;
          backendProcessing = false;
          shouldClearTranscription = true;
          updateMicStatus();
        });

        socket.on("transcription", (text) => {
          // Partial transcription - append to existing text
          if (transcription.value) {
            transcription.value += " " + text;
          } else {
            transcription.value = text;
          }
        });

        socket.on("final_transcription_result", async (data) => {
          transcription.value = data;
          await processCommand(generated_image.alt, data);
        });

        socket.on("llm_response", (data) => {
          llm_response.value = data;
          processJussiRasku(data);
        });

        socket.on("command_result", async (result) => {
          if (result.image) {
            generated_image.src = `/kuvagen/images/${result.image}`;
            generated_image.alt = result.image;
            system_status.textContent = "Done! Ready for next command.";
            await loadSessionInfo();
            if (!result.action || result.action !== "undo") {
              processJussiRasku("done:");
            }
          }
          backendProcessing = false;
          shouldClearTranscription = true;
          updateMicStatus();
          spinner_cont.style.display = "none";
          updateGallery();
        });

        socket.on("command_error", (error) => {
          system_status.textContent = "Error: " + error;
          processJussiRasku("error:");
          backendProcessing = false;
          shouldClearTranscription = true;
          updateMicStatus();
          spinner_cont.style.display = "none";
        });

        socket.on("generation_progress", (data) => {
          system_status.textContent = `Generating... ${data.progress}%`;
        });

        socket.on("generation_preview", (data) => {
          if (data.preview) {
            generated_image.src = `data:image/png;base64,${data.preview}`;
          }
        });

        socket.on("image_progress", (data) => {
          generated_image.src = "data:image/png;base64," + data;
        });

        socket.on("error", (data) => {
          console.error("Error:", data);
          system_status.textContent = data;
          processJussiRasku("error:");
          backendProcessing = false;
          shouldClearTranscription = true;
          updateMicStatus();
          spinner_cont.style.display = "none";
        });

        // Backend progress events
        socket.on("task_queued", (data) => {
          console.log("Task queued:", data);
          system_status.textContent = `Queued (position: ${data.position})...`;
          spinner_cont.style.display = "flex";
        });

        socket.on("backend_queue_position", (data) => {
          console.log("Queue position update:", data);
          system_status.textContent = `In queue (position: ${data.position})...`;
        });

        socket.on("backend_processing_started", (data) => {
          console.log("Processing started:", data);
          system_status.textContent = "Processing image...";
        });

        socket.on("backend_progress", (data) => {
          console.log("Progress update:", data);
          const progress = data.progress;
          if (progress) {
            const percentage = Math.round((progress.step / progress.total_steps) * 100);
            system_status.textContent = `Generating... ${progress.step}/${progress.total_steps} (${percentage}%)`;
          }
        });

        socket.on("backend_preview", (data) => {
          console.log("Preview received");
          if (data.preview) {
            generated_image.src = `data:image/png;base64,${data.preview}`;
          }
        });

        socket.on("backend_completed", async (data) => {
          console.log("Backend completed:", data);
          // Process the completed image via backend_image_ready
          socket.emit("backend_image_ready", data);
        });

        socket.on("backend_error", (data) => {
          console.error("Backend error:", data);
          system_status.textContent = "Error: " + data.error;
          processJussiRasku("error:");
          backendProcessing = false;
          shouldClearTranscription = true;
          updateMicStatus();
          spinner_cont.style.display = "none";
        });

        socket.on("image_ready", async (data) => {
          console.log("Image ready:", data);
          if (data.image) {
            generated_image.src = `/kuvagen/images/${data.image}`;
            generated_image.alt = data.image;
            system_status.textContent = "Done! Ready for next command.";
            await loadSessionInfo();
            processJussiRasku("done:");
          }
          backendProcessing = false;
          shouldClearTranscription = true;
          updateMicStatus();
          spinner_cont.style.display = "none";
          updateGallery();
        });
      }

      async function initializeMicrophone() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: {
              echoCancellation: false,
              autoGainControl: false,
              noiseCancellation: false,
            },
          });

          // Initialize VAD for partial transcriptions during push-to-talk
          console.log("Initializing VAD for partial transcriptions");
          myvad = await vad.MicVAD.new({
            stream: stream,
            positiveSpeechThreshold: 0.8,
            negativeSpeechThreshold: 0.6,
            minSpeechFrames: 1,
            preSpeechPadFrames: 5,
            redemptionFrames: 3,
            onSpeechStart: () => {
              console.log("VAD: Speech start detected");
              if (!isRecording || backendProcessing) {
                return;
              }
              hasAudioData = true;
              mic_status_box.style.boxShadow = "0 0 5px 5px lightgreen";
              updateMicStatus();
            },
            onSpeechEnd: (audio) => {
              console.log("VAD: Speech end detected");
              if (!isRecording || backendProcessing) {
                return;
              }
              mic_status_box.style.boxShadow = "";
              updateMicStatus();

              // Send partial audio for transcription
              if (!socket || !socket.connected) {
                return;
              }
              const wavBuffer = vad.utils.encodeWAV(audio);
              const base64 = vad.utils.arrayBufferToBase64(wavBuffer);
              socket.emit("audio_data", base64);
            },
          });

          // Start VAD in paused state (will be activated during push-to-talk)
          myvad.pause();

          // Set up AudioContext for real-time audio level detection
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;
          const source = audioContext.createMediaStreamSource(stream);
          source.connect(analyser);

          mediaRecorder = new MediaRecorder(stream);

          mediaRecorder.ondataavailable = (e) => {
            audioChunks.push(e.data);
          };

          mediaRecorder.onstop = () => {
            const blob = new Blob(audioChunks, { type: "audio/webm" });
            audioChunks = [];

            const reader = new FileReader();
            reader.readAsDataURL(blob);
            reader.onloadend = () => {
              const base64 = reader.result.split(",")[1];
              socket.emit("full_audio_data", base64);
            };
          };

          // Keyboard controls
          document.body.onkeydown = (e) => {
            if (e.code === "Space" && !backendProcessing && !isSpacePressed) {
              e.preventDefault();
              startRecording();
            }
          };

          document.body.onkeyup = (e) => {
            if (e.code === "Space" && !backendProcessing && isSpacePressed) {
              e.preventDefault();
              stopRecording();
            }
          };

          console.log("Microphone initialized with VAD support");
        } catch (error) {
          console.error("Microphone error:", error);
          system_status.textContent = "Microphone access denied";
        }
      }

      function startRecording() {
        if (isSpacePressed) return;

        isSpacePressed = true;
        isRecording = true;
        hasAudioData = false; // Reset audio data flag

        if (shouldClearTranscription) {
          transcription.value = "";
          llm_response.value = "";
          shouldClearTranscription = false;
        }

        audioChunks = [];
        // Start VAD for partial transcriptions
        if (myvad) {
          myvad.start();
          console.log("VAD started for partial transcriptions");
        }
        // Start MediaRecorder for full audio
        mediaRecorder.start();
        system_status.textContent = "Recording...";
        mic_help.textContent = "Release spacebar";

        // Start real-time audio level monitoring
        startAudioLevelMonitoring();

        // Update status (no glow until audio detected)
        updateMicStatus();
      }

      function stopRecording() {
        isSpacePressed = false;
        isRecording = false;
        hasAudioData = false; // Reset audio data flag

        // Stop audio level monitoring
        stopAudioLevelMonitoring();

        // Pause VAD
        if (myvad) {
          myvad.pause();
          console.log("VAD paused");
        }

        // Stop MediaRecorder after a short delay to capture final audio
        setTimeout(() => {
          mediaRecorder.stop();
        }, 500);

        system_status.textContent = "Processing audio...";
        mic_help.textContent = "Hold spacebar";

        // Update status and remove visual feedback
        updateMicStatus();
      }

      function updateMicStatus() {
        const mic_icon_closed = document.getElementById("mic_icon_closed");
        const mic_icon_open = document.getElementById("mic_icon_open");
        let status = "Unknown";

        // Reset styles
        mic_status_box.style = "";

        if (backendProcessing) {
          status = "Processing";
          // Remove box shadow during processing
          mic_status_box.style.boxShadow = "";
        } else if (isRecording) {
          status = "Listening";
          // Only add reactive box shadow when actual audio is detected
          if (hasAudioData) {
            mic_status_box.style.boxShadow = "0 0 5px 5px lightgreen";
          } else {
            mic_status_box.style.boxShadow = "";
          }
        } else {
          status = "Muted";
          // Remove box shadow when muted
          mic_status_box.style.boxShadow = "";
        }

        mic_status_txt.innerText = status;
        if (status === "Listening") {
          mic_status_box.style.borderColor = "lightgreen";
          mic_status_box.style.color = "lightgreen";
          mic_icon_closed.style.display = "none";
          mic_icon_open.style.display = "block";
        } else if (status === "Muted") {
          mic_status_box.style.borderColor = "lightcoral";
          mic_status_box.style.color = "lightcoral";
          mic_icon_closed.style.display = "block";
          mic_icon_open.style.display = "none";
        } else {
          mic_status_box.style.borderColor = "yellow";
          mic_status_box.style.color = "yellow";
          mic_icon_closed.style.display = "block";
          mic_icon_open.style.display = "none";
        }
      }

      function startAudioLevelMonitoring() {
        if (!analyser) return;

        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        const audioThreshold = 25; // Adjust this value to change sensitivity (lower = more sensitive)

        audioLevelCheckInterval = setInterval(() => {
          if (!isRecording) {
            stopAudioLevelMonitoring();
            return;
          }

          analyser.getByteFrequencyData(dataArray);

          // Calculate average audio level
          let sum = 0;
          for (let i = 0; i < bufferLength; i++) {
            sum += dataArray[i];
          }
          const average = sum / bufferLength;

          // Update hasAudioData based on audio level
          const previousHasAudioData = hasAudioData;
          hasAudioData = average > audioThreshold;

          // Only update visual feedback if the state changed
          if (previousHasAudioData !== hasAudioData) {
            updateMicStatus();
          }
        }, 50); // Check every 50ms for responsive feedback
      }

      function stopAudioLevelMonitoring() {
        if (audioLevelCheckInterval) {
          clearInterval(audioLevelCheckInterval);
          audioLevelCheckInterval = null;
        }
      }

      async function processCommand(image, command) {
        if (!sessionInfo.can_generate) {
          alert("Image generation limit reached!");
          return;
        }

        backendProcessing = true;
        updateMicStatus();
        spinner_cont.style.display = "flex";
        system_status.textContent = "Processing command...";

        try {
          socket.emit("process_command", { image, command });
        } catch (error) {
          console.error("Command processing error:", error);
          system_status.textContent = "Error: " + error.message;
          backendProcessing = false;
          shouldClearTranscription = true;
          updateMicStatus();
          spinner_cont.style.display = "none";
        }
      }

      // Language selection
      rb_auto.addEventListener("change", () => {
        language = "";
        socket?.emit("lang_select", "");
      });

      rb_en.addEventListener("change", () => {
        language = "en";
        socket?.emit("lang_select", "en");
      });

      rb_fi.addEventListener("change", () => {
        language = "fi";
        socket?.emit("lang_select", "fi");
      });

      // Model selection
      rb_local_fast.addEventListener("change", () => {
        selectedModel = "localfast";
        socket?.emit("mdl_select", "localfast");
      });

      rb_local_slow.addEventListener("change", () => {
        selectedModel = "localslow";
        socket?.emit("mdl_select", "localslow");
      });

      rb_cloud.addEventListener("change", () => {
        selectedModel = "cloud";
        socket?.emit("mdl_select", "cloud");
      });

      // Gallery and tree view
      gallery_button.addEventListener("click", () => {
        showGallery();
      });

      chart_button.addEventListener("click", () => {
        showTreeView(generated_image.alt);
      });

      function showMainPage(image_name) {
        main_page.style.display = "flex";
        gallery.style.display = "none";
        panzoom_parent.style.display = "none";
        image_name = image_name.split("?")[0];
        generated_image.src = `/kuvagen/images/${image_name}`;
        generated_image.alt = image_name;
        body.style.overflow = "auto";
        body.style.cursor = "default";
      }

      function showGallery() {
        if (!socket || !socket.connected) {
          return;
        }
        main_page.style.display = "none";
        gallery.style.display = "flex";
        panzoom_parent.style.display = "none";
        body.style.overflow = "auto";
        body.style.cursor = "default";
      }

      function showTreeView(image_name) {
        if (!socket || !socket.connected) {
          return;
        }
        main_page.style.display = "none";
        gallery.style.display = "none";
        panzoom_parent.style.opacity = 0;
        panzoom_parent.style.display = "flex";
        body.style.overflow = "hidden";
        body.style.cursor = "move";
        generateTreeView(image_name);
      }

      async function updateGallery() {
        try {
          const response = await fetch("/kuvagen/images");
          const images = await response.json();

          images.forEach((image) => {
            if (!displayedImages.has(image.name)) {
              const container = document.createElement("div");
              container.className = "image-container";

              const img = document.createElement("img");
              img.src = `/kuvagen/images/${image.name}`;
              img.alt = image.name;
              img.addEventListener("click", () => {
                showMainPage(image.name);
              });

              const overlay = document.createElement("div");
              overlay.className = "overlay";
              overlay.textContent = image.prompt;

              const downloadBtn = document.createElement("button");
              downloadBtn.className = "download-btn";
              downloadBtn.innerHTML = '<i class="fa fa-download"></i>';
              downloadBtn.addEventListener("click", (e) => {
                e.stopPropagation();
                downloadImage(image.name);
              });

              container.appendChild(img);
              container.appendChild(overlay);
              container.appendChild(downloadBtn);
              gallery.insertBefore(container, gallery.firstChild);

              displayedImages.add(image.name);
            }
          });
        } catch (error) {
          console.error("Error fetching gallery:", error);
        }
      }

      function downloadImage(imageName) {
        const link = document.createElement("a");
        link.href = `/kuvagen/images/${imageName}`;
        link.download = `${imageName}.webp`;
        link.click();
      }

      async function generateTreeView(image_name) {
        try {
          const response = await fetch("/kuvagen/gallery");
          const galleryJson = await response.json();

          function findNodeByName(name, nodes) {
            return nodes.find((node) => node.name === name);
          }

          function buildTree(nodeName, nodes) {
            const node = findNodeByName(nodeName, nodes);
            if (!node) return null;

            const children = nodes
              .filter((n) => n.parent === nodeName)
              .map((n) => buildTree(n.name, nodes))
              .filter(Boolean);

            return {
              text: { name: node.prompt },
              children: [
                {
                  image: `/kuvagen/images/${node.name}`,
                  children: children,
                },
              ],
            };
          }

          function findRootNode(nodeName, nodes) {
            let currentNode = findNodeByName(nodeName, nodes);
            while (currentNode && currentNode.parent) {
              currentNode = findNodeByName(currentNode.parent, nodes);
            }
            return currentNode;
          }

          const rootNode = findRootNode(image_name, galleryJson);
          if (!rootNode) {
            console.error("Root node not found");
            return;
          }

          const nodeStructure = buildTree(rootNode.name, galleryJson);

          const chart_config = {
            chart: {
              container: "#tree_view",
              rootOrientation: "WEST",
              connectors: {
                type: "curve",
                style: {
                  "stroke-width": 2,
                  stroke: "white",
                },
              },
            },
            nodeStructure: nodeStructure,
          };

          new Treant(chart_config, function () {
            const images = document.querySelectorAll(".node img");
            images.forEach((img) => {
              img.addEventListener("click", () => {
                showMainPage(img.src.split("/images/")[1]);
              });
            });

            const screenSize = {
              w: Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
              h: Math.max(document.documentElement.clientHeight, window.innerHeight || 0),
            };
            const elemWid = tree_view.offsetWidth;
            const elemHei = tree_view.offsetHeight;
            const initialZoom = Math.min(screenSize.w / elemWid, screenSize.h / elemHei);
            panzoom_element.zoomAbs(0, 0, initialZoom * 0.9);
            panzoom_element.moveTo((screenSize.w - elemWid * initialZoom) / 2 - screenSize.w * 0.3, (screenSize.h - elemHei * initialZoom) / 2);
            panzoom_parent.style.opacity = 1;
          });
        } catch (error) {
          console.error("Error generating tree view:", error);
        }
      }

      // Character interaction
      let counter = 1;
      function changeAvatar() {
        counter++;
        switch (counter) {
          case 1:
            speechBubbleEnabled = false;
            logo_image.style.display = "none";
            jr_image.src = "https://raw.githubusercontent.com/Koodattu/ucs-llm-voice-image-edit/main/assets/gls_wide.png";
            processJussiRasku("init:gls");
            break;
          case 2:
            speechBubbleEnabled = true;
            logo_image.style.display = "block";
            jr_image.src = "https://raw.githubusercontent.com/Koodattu/ucs-llm-voice-image-edit/main/assets/jr.png";
            processJussiRasku("init:jr");
            break;
          case 3:
            speechBubbleEnabled = true;
            logo_image.style.display = "block";
            jr_image.src = "https://raw.githubusercontent.com/Koodattu/ucs-llm-voice-image-edit/main/assets/jar.png";
            processJussiRasku("init:jar");
            break;
          case 4:
            speechBubbleEnabled = true;
            logo_image.style.display = "block";
            jr_image.src = "https://raw.githubusercontent.com/Koodattu/ucs-llm-voice-image-edit/main/assets/pa.png";
            counter = 0;
            processJussiRasku("init:pa");
            break;
        }
      }

      jr_image.addEventListener("click", function () {
        changeAvatar();
      });

      let timer = null;
      function processJussiRasku(data) {
        let newText = language === "fi" ? "Nyt en ihan ymmärtänyt, yritä uudestaan!" : "I didn't quite get that, try again!";
        if (data.startsWith("init:")) {
          const guy = data.split(":")[1];
          newText = responses[language].initReplies[guy];
        } else if (data.startsWith("create:")) {
          newText = responses[language].createReplies[Math.floor(Math.random() * responses[language].createReplies.length)];
        } else if (data.startsWith("edit:")) {
          newText = responses[language].editReplies[Math.floor(Math.random() * responses[language].editReplies.length)];
        } else if (data.startsWith("video:")) {
          newText = responses[language].videoReplies[Math.floor(Math.random() * responses[language].videoReplies.length)];
        } else if (data.startsWith("undo:")) {
          newText = responses[language].undoReplies[Math.floor(Math.random() * responses[language].undoReplies.length)];
        } else if (data.startsWith("error:")) {
          newText = responses[language].errorReplies[Math.floor(Math.random() * responses[language].errorReplies.length)];
        } else if (data.startsWith("done:")) {
          newText = responses[language].doneReplies[Math.floor(Math.random() * responses[language].doneReplies.length)];
        }

        if (timer) {
          clearTimeout(timer);
        }

        function startTimer() {
          timer = setTimeout(() => {
            newText = responses[language].createOrEditReminderReplies[Math.floor(Math.random() * responses[language].createOrEditReminderReplies.length)];
            changeBubbleText(newText);
            startTimer();
          }, 30000);
        }

        startTimer();

        changeBubbleText(newText);
      }

      function changeBubbleText(newText) {
        // Fade out and move up
        speech_bubble.style.opacity = "0";
        speech_bubble.style.transform = "translate(0, -60%)";

        if (!speechBubbleEnabled) {
          return;
        }

        // After the fade out and move up is complete, change the text and reset position
        setTimeout(() => {
          speech_bubble.innerText = newText;
          speech_bubble.style.transition = "none"; // Temporarily disable transition for instant position reset
          speech_bubble.style.transform = "translate(0, 60%)"; // Move to the bottom
          speech_bubble.style.opacity = "0"; // Keep it invisible
          // Trigger reflow to apply styles immediately
          void speech_bubble.offsetHeight;

          // Fade in and move to original position
          speech_bubble.style.transition = "all 0.5s ease-in-out";
          speech_bubble.style.transform = "translate(0, 0)";
          speech_bubble.style.opacity = "1";
        }, 500); // Wait for the fade out animation to complete
      }
      const responses = {
        en: {
          initReplies: {
            jr: "Try saying: Make me a new image of an AI agent?",
            jar: "Now this is imaging!",
            pa: "Let's create ten thousand AI agents!",
            gls: "",
          },
          createOrEditReminderReplies: [
            "Try saying something like 'make me a new image of an AI agent'",
            "New image? Say something like 'create an image of the seaside'",
            "Need an image idea? Try saying 'new image of a Finnish forest'?",
            "How about winter in the picture? Say 'edit the image to be wintery'",
            "Edit idea? 'edit the image with a starry sky'",
            "How about, 'what if it was night in the picture'?",
            "This is also possible: 'make a video from this image'",
            "You probably didn't guess this: 'make a video from the image'",
            "Didn't like it? Say 'go back to the previous image'",
            "If you're not satisfied, you can say 'let's cancel this change'",
          ],
          createReplies: [
            "Creating an image, it won't take long!",
            "Image is being created, don't worry!",
            "A new image is coming, stay tuned!",
            "Creating a masterpiece, don't get nervous!",
            "A new image is coming up, be patient!",
            "Setting up the image, just a moment!",
            "It'll be ready soon, stay with us!",
            "The image is almost done, hold on!",
            "Creating an image, it will take a bit!",
            "Image creation in progress, wait a moment!",
          ],
          editReplies: [
            "Editing the image, hope for the best!",
            "Image is being edited, patience!",
            "Image tweaking in progress, hold on!",
            "Improving the image, almost ready!",
            "Editing the image, stay calm!",
            "Reworking the image, just a moment!",
            "Tweaking the image, wait a moment!",
            "Image editing in progress, just a moment!",
            "Editing the image, hold on!",
            "Fine-tuning the image, wait a moment!",
          ],
          videoReplies: [
            "Creating a video, it will take a moment!",
            "Video processing, patience!",
            "Working on the video, stay calm!",
            "Video creation in progress, wait!",
            "Making a video, please wait!",
            "Starting the video, just a moment!",
            "Video creation started, hold on!",
            "Creating the video, stay tuned!",
            "Making a video, just a moment!",
            "Video in progress, hold on!",
          ],
          undoReplies: [
            "Didn't go quite right!",
            "Sometimes it happens, try again!",
            "Didn't hit the mark? No worries!",
            "Didn't get the desired result?",
            "It doesn't always work, but keep trying!",
            "It didn't go as planned...",
            "A small mistake can be a big discovery!",
            "No failures, only lessons!",
            "Failure is a step forward!",
            "No mistakes, only happy accidents!",
          ],
          errorReplies: [
            "Something went wrong, try again!",
            "An error occurred, please try again!",
            "Oops, it went wrong, try again!",
            "Something went wrong, try again!",
            "Error detected, try again!",
            "An error occurred, try again!",
            "It didn't go well, try again!",
            "Error situation, try again!",
            "Something went wrong, try again!",
            "Oops, try again!",
          ],
          doneReplies: [
            "Here's the result, what do you think? It's not a dog without fur!",
            "Image is ready, is it good? Made by us!",
            "It's done, do you like it? We'll do even better next time!",
            "Image is ready, what do you say? Better one bird in the hand than ten in the bush!",
            "Here's the result, how does it look? Not just any bird!",
            "Ready image, is it acceptable? Not bad, even if I say so myself!",
            "Here's the result, what do you think? Better than the neighbor's dog!",
            "Now it's pretty, isn't it? Fits like a glove!",
            "Here's the ready image, do you like it? It didn't go like Strömsholm!",
            "Image ready, what's the feeling? Made by me!",
          ],
        },
        fi: {
          initReplies: {
            jr: 'Koita vaikka sanoa notta "tees mulle uus kuva tekoälyagentista"?',
            jar: "Tekoäly agenttina liikenteessä!",
            pa: "Tehdään kymmenen tuhatta tekoälyagenttia!",
            gls: "",
          },
          createOrEditReminderReplies: [
            "Koita vaikka sanoa notta 'tees mulle uus kuva tekoälyagentista'",
            "Uuteen kuvaan? Sano vaikka 'luo kuva merenrannasta'",
            "Kuvaidea hukassa? Koita vaikka 'uusi kuva Suomen metsästä'?",
            "Mitä jos kuvassa olisikin talvi? Sano vaikka 'muokkaa kuvaa talviseksi'",
            "Muokkausidea? 'muokkaa kuvaan tähtitaivas'",
            "Mites vaikka, 'mitä jos kuvassa olisi yö'?",
            "Tämäkin on mahdollista: 'tee tästä kuvasta video'",
            "Tätä et pakosti arvannut: 'tees kuvasta video'",
            "Ei tullu mieluista? Sano että 'mennään edelliseen kuvaan'",
            "Jos et ole tyytyväinen, voit sanoa 'perutaan tämä muutos'",
          ],
          createReplies: [
            "Pistetään kuvaa tulille, ei kestä kauaa!",
            "Kuvaa väsätään, älä hättäile!",
            "Uutta kuvaa pukkaa, pysy linjoilla!",
            "Luodaan mestariteosta, älä hermostu!",
            "Uutta kuvaa syntyy, malta mieles!",
            "Viritellään kuvaa, hetki vain!",
            "Kohta se o valmis, pysy kyydissä!",
            "Kuva on kohta näpissä, malta hetki!",
            "Luodaan kuvaa, kestää vähän!",
            "Kuvanteko käynnissä, odotahan pieni hetki!",
          ],
          editReplies: [
            "Muokataan kuvaa, toivotaan parasta!",
            "Kuvaa muokataan, kärsivällisyyttä!",
            "Kuvan viilaus menossa, malta hetki!",
            "Parannellaan kuvaa, kohta valmista!",
            "Muokataan kuvaa, pysy rauhassa!",
            "Uusiks pistetään kuvaa, hetki vaan!",
            "Kuvaa viilataan, oota hetki!",
            "Kuvan editointi käynnissä, hetki vaan!",
            "Muokataan kuvaa, malttia!",
            "Viilataan kuvaa, oota hetki!",
          ],
          videoReplies: [
            "Videota tehhään, hetki menee!",
            "Videon käsittelyssä, kärsivällisyyttä!",
            "Videota työstetään, pysy rauhallisena!",
            "Videon luominen käynnissä, odota!",
            "Videota tehtäessä, odotahan!",
            "Pistetään video käyntiin, hetki vaan!",
            "Videon teko aloitettu, malta hetki!",
            "Videota syntyy, pysy linjoilla!",
            "Videota luodaan, oota pieni hetki!",
            "Video työn alla, malta hetki!",
          ],
          undoReplies: [
            "Eipä tainnu mennä ihan putkeen!",
            "Joskus käy näin, uudestaan vaan!",
            "Ei osunu nappiin? Ei hätää!",
            "Ei tullut toivottua tulosta?",
            "Aina ei onnistu, mutta yrittänyttä ei laiteta!",
            "Ei menny niinku Strömssössä...",
            "Pieni virhe voi olla suuri löytö!",
            "Ei oo epäonnistumisia, on vaan oppeja!",
            "Epäonnistuminen on askel eteenpäin!",
            "Ei virheitä, vain iloisia vahinkoja!",
          ],
          errorReplies: [
            "Jotain meni pieleen, yritä uusiks!",
            "Virhe tapahtu, kokeilepa uudelleen!",
            "Hups, vikaan meni, yritä uusiks!",
            "Jokin meni pieleen, koetahan uudelleen!",
            "Virhe havaittu, yritä uusiks!",
            "Tapahtu virhe, koita uudelleen!",
            "Ei menny putkeen, yritä uusiks!",
            "Virhetilanne, yritäpä uusiks!",
            "Jokin meni vikaan, koita uudelleen!",
            "Hupsista, kokeile uusiks!",
          ],
          doneReplies: [
            "Tälläänen siitä tuli, mitä tykkäät? Ei oo koira karvoistansa!",
            "Kuva valmis, onko hyvä? Meirän tekemä!",
            "Valmista tuli, maistuuko? Pannaan paremmaksi ens kerralla!",
            "Kuva on valmis, mitäs sanot? Parempi pyy pivossa ku kymmenen oksalla!",
            "Tässä on lopputulos, miltä näyttää? Ei mikään harakanvarvas!",
            "Valmis kuva, kelpaako? Ei hassumpi, vaikka itte sanon!",
            "Lopputulos tässä, mitä tuumit? Parempi ku naapurin koira!",
            "Nyt tuli nätti, eikös vain? Käy ku nenä päähän!",
            "Tässä valmis kuva, mitäs tykkäät? Eikä mennyt ku Strömssöössä!",
            "Kuva valmis, mikä fiilis? Meikä mankeli tekase!",
          ],
        },
      };
    </script>
  </body>
</html>
